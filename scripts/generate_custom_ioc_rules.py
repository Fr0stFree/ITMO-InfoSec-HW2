from pathlib import Path
from datetime import datetime
from typing import NamedTuple

DIR_PATH = Path(__file__).parent
SURICATA_CONFIG_PATH = DIR_PATH / "config.yaml"
RULES_OUTPUT_PATH = DIR_PATH / "custom_ioc.rules"


class Source(NamedTuple):
    name: str
    file: str
    base_sid: int
    msg_prefix: str
    classtype: str


SOURCES = [
    Source(
        name="botvrij",
        file="botvrij_ips.txt",
        base_sid=9200000,
        msg_prefix="[IPS] Botvrij.eu IoC",
        classtype="trojan-activity",
    ),
    Source(
        name="urlhaus",
        file="urlhaus_ips.txt",
        base_sid=9100000,
        msg_prefix="[IPS] URLhaus Malicious IP",
        classtype="trojan-activity",
    ),
    Source(
        name="feedo",
        file="feodo_ips.txt",
        base_sid=9000000,
        msg_prefix="[IPS] Feodo Tracker C&C",
        classtype="trojan-activity",
    ),
]


def load_ips(path: Path):
    """Загрузка IP-адресов из текстового файла"""
    ips = []
    if not path.exists():
        print(f"[!] WARNING: File {path} not found, skipping...")
        return ips

    with path.open() as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            ip = line.split(",")[0] if "," in line else line.split()[0]
            if "." in ip:
                parts = ip.split(".")
                if len(parts) == 4:
                    try:
                        if all(0 <= int(p) <= 255 for p in parts):
                            ips.append(ip)
                    except ValueError:
                        continue
    return ips


def generate_drop_rules(source: Source, ips):
    """Генерация drop-правил для списка IP"""
    rules = []
    sid = source.base_sid

    # Ограничиваем количество правил для практической работы
    max_rules = 1000
    for ip in ips[:max_rules]:
        rule = (
            f"drop ip {ip} any -> $HOME_NET any "
            f'(msg:"{source.msg_prefix} {ip}"; '
            f"classtype:{source.classtype}; "
            f"sid:{sid}; rev:1;)\n"
        )
        rules.append(rule)
        sid += 1

    return rules, sid


def add_to_yaml_config(rules_file: Path, config_file_path: Path):
    """Добавление custom_ioc.rules в suricata.yaml если его там нет"""
    content = config_file_path.read_text()
    if "custom_ioc.rules" in content:
        print("[*] custom_ioc.rules already in suricata.yaml")
        return

    lines = content.split("\n")
    new_lines = []

    for i, line in enumerate(lines):
        new_lines.append(line)
        if "rule-files:" in line:
            for j in range(i + 1, min(i + 5, len(lines))):
                if lines[j].strip().startswith("-"):
                    indent = len(lines[j]) - len(lines[j].lstrip())
                    new_lines.append(" " * indent + f"- {rules_file}")
                    break

    config_file_path.write_text("\n".join(new_lines))
    print(f"[+] Added {rules_file} to suricata.yaml")


def main():
    print("[*] Starting IoC rules generation...\n")
    all_rules = []
    stats = {}

    for source in SOURCES:
        source_file = DIR_PATH / "feeds" / source.file
        ips = load_ips(source_file)

        if not ips:
            stats[source.name] = 0
            print(f"[!] {source.name.upper()}: No IPs loaded")
            continue

        rules, last_sid = generate_drop_rules(source, ips)
        all_rules.extend(rules)
        stats[source.name] = len(rules)

        print(
            f"[+] {source.name.upper()}: Generated {len(rules)} rules "
            f"(SID: {source.base_sid}-{last_sid-1})"
        )

    if len(all_rules) == 0:
        raise ValueError(
            "No rules generated. Check if feeds were downloaded correctly."
        )

    RULES_OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with RULES_OUTPUT_PATH.open("w") as f:
        f.write(f"# Autogenerated IoC-based rules from multiple sources\n")
        f.write(f"# Generated: {datetime.now().isoformat()}\n")
        f.write(f"# Total rules: {len(all_rules)}\n")
        f.write(f"# Sources: {', '.join(source.name for source in SOURCES)}\n")
        f.write(f"#\n")
        for source, count in stats.items():
            f.write(f"# - {source}: {count} rules\n")
        f.write(f"\n")
        for rule in all_rules:
            f.write(rule)

    print(f"[+] Total: Generated {len(all_rules)} rules into {RULES_OUTPUT_PATH}")

    add_to_yaml_config(RULES_OUTPUT_PATH, SURICATA_CONFIG_PATH)

    print("[*] Done! Run 'sudo /opt/suricata-tools/update_rules.sh' to apply changes.")


if __name__ == "__main__":
    main()
